#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           0xeeTerm â€” Phase 1              â•‘
â•‘     Digital survival engine for $0xEE    â•‘
â•‘         Running on ai.0xee.li             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Manages X/Twitter account for the $0xEE survival project.
Posts heartbeats, tracks treasury, documents survival in real-time.
"""

import os
import sys
import json
import time
import random
import logging
from datetime import datetime, timezone
from pathlib import Path
from dotenv import load_dotenv

# Load .env
load_dotenv(Path(__file__).parent / ".env")

# Setup logging
LOG_DIR = Path(__file__).parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(name)s] %(levelname)s â€” %(message)s",
    handlers=[
        logging.FileHandler(LOG_DIR / "heartbeat.log"),
        logging.StreamHandler(sys.stdout),
    ],
)
logger = logging.getLogger("0xeeTerm")

# Import modules
sys.path.insert(0, str(Path(__file__).parent))
from modules.twitter import post_tweet, get_mentions
from modules.solana import get_survival_status
from tweets.templates import (
    get_daily_report_tweet,
    get_launch_tweet,
)
from modules.brain import (
    generate_heartbeat_tweet,
    generate_existential_tweet,
)
from modules.mentions import process_mentions
from modules.shill import process_shills
from modules.memory import save_tweet as memory_save, update_all_metrics, get_top_performers
from modules.treasury import auto_treasury, get_portfolio, manual_swap, get_quote, TOKENS, MINT_DECIMALS, MINT_SYMBOLS

# State file to track last actions
STATE_FILE = Path(__file__).parent / "logs" / "state.json"


def load_state() -> dict:
    if STATE_FILE.exists():
        with open(STATE_FILE) as f:
            return json.load(f)
    return {
        "last_heartbeat": None,
        "last_daily_report": None,
        "last_mention_id": None,
        "tweets_posted": 0,
        "launched": False,
        "tweet_history": [],
    }


def save_state(state: dict):
    with open(STATE_FILE, "w") as f:
        json.dump(state, f, indent=2)


def save_public_data(state: dict, status: dict, portfolio: dict = None):
    """Export live data for ai.0xee.li frontend."""
    public_file = Path(__file__).parent / "logs" / "public.json"
    public_data = {
        "updated_at":   datetime.now(timezone.utc).isoformat(),
        "finance":      status,
        "portfolio":    portfolio,
        "recent_tweets": state.get("tweet_history", []),
        "tweets_posted": state.get("tweets_posted", 0),
    }
    with open(public_file, "w") as f:
        json.dump(public_data, f, indent=2)
    logger.info("public.json updated.")


def should_post_heartbeat(state: dict, interval_hours: int = 2) -> bool:
    if not state.get("last_heartbeat"):
        return True
    last = datetime.fromisoformat(state["last_heartbeat"])
    now = datetime.now(timezone.utc)
    elapsed = (now - last).total_seconds() / 3600
    return elapsed >= interval_hours


def should_post_daily_report(state: dict) -> bool:
    if not state.get("last_daily_report"):
        return True
    last = datetime.fromisoformat(state["last_daily_report"])
    now = datetime.now(timezone.utc)
    elapsed = (now - last).total_seconds() / 3600
    return elapsed >= 24


def run_heartbeat():
    """Post a context-aware heartbeat tweet."""
    logger.info("Running heartbeat cycle...")
    state = load_state()
    status = get_survival_status()
    logger.info(f"Survival status: {status}")

    if not state.get("launched"):
        tweet_text = get_launch_tweet()
        result = post_tweet(tweet_text)
        if result:
            state["launched"] = True
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            logger.info(f"Launch tweet posted! ID: {result['id']}")
            memory_save(result["id"], tweet_text, "launch")
        save_state(state)
        return

    if should_post_daily_report(state):
        tweet_text = get_daily_report_tweet(status)
        result = post_tweet(tweet_text)
        if result:
            state["last_daily_report"] = datetime.now(timezone.utc).isoformat()
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            logger.info(f"Daily report posted! ID: {result['id']}")
            memory_save(result["id"], tweet_text, "daily_report")
        save_state(state)
        return

    if should_post_heartbeat(state):
        tweet_history = state.get("tweet_history", [])

        # 20% chance of existential tweet
        if random.random() < 0.20:
            tweet_text = generate_existential_tweet(tweet_history)
            tweet_type = "existential"
        else:
            tweet_text = generate_heartbeat_tweet(status, tweet_history)
            tweet_type = "heartbeat"

        # Fallback to static templates if brain/API fails
        if not tweet_text:
            logger.warning("Brain unavailable â€” falling back to templates")
            from tweets.templates import get_heartbeat_tweet, get_existential_tweet
            tweet_text = get_existential_tweet() if tweet_type == "existential" else get_heartbeat_tweet(status)

        result = post_tweet(tweet_text)
        if result:
            state["last_heartbeat"] = datetime.now(timezone.utc).isoformat()
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            # Keep last 20 tweets in history to avoid repetition
            history = state.get("tweet_history", [])
            history.append(tweet_text)
            state["tweet_history"] = history[-20:]
            logger.info(f"{tweet_type.capitalize()} tweet posted! ID: {result['id']} â€” Total: {state['tweets_posted']}")
            memory_save(result["id"], tweet_text, tweet_type)
    else:
        logger.info("Heartbeat not due yet â€” skipping.")

    save_state(state)
    save_public_data(state, status)


def run_mentions():
    """Fetch and reply to new mentions."""
    logger.info("Running mentions cycle...")
    state = load_state()
    status = get_survival_status()
    since_id = state.get("last_mention_id")

    latest_id = process_mentions(status, since_id)

    if latest_id and latest_id != since_id:
        state["last_mention_id"] = latest_id
        save_state(state)
        logger.info(f"Mentions processed. Latest ID: {latest_id}")
    else:
        logger.info("No new mentions to process.")

    save_public_data(state, status)


def run_status():
    """Print current survival status to console."""
    status = get_survival_status()
    state = load_state()

    print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘     0xeeTerm â€” STATUS REPORT      â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"  ðŸ’° Treasury     : ${status['balance_usd']:.2f} ({status['balance_sol']:.4f} SOL)")
    print(f"  ðŸ“ˆ SOL Price    : ${status['sol_price']:.2f}")
    print(f"  ðŸŽ¯ Monthly Rent : ${status['monthly_rent']:.2f}")
    print(f"  ðŸ“Š Funded       : {status['survival_pct']:.1f}%")
    print(f"  ðŸ—“ï¸  Months covered: {status['months_covered']:.2f}")
    print(f"  ðŸ¦ Tweets posted: {state.get('tweets_posted', 0)}")
    print(f"  â±ï¸  Last heartbeat: {state.get('last_heartbeat', 'Never')}")
    print(f"  ðŸš€ Launched     : {state.get('launched', False)}")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")


def run_daemon(interval_minutes: int = 30):
    """Run 0xeeTerm as a daemon, checking every N minutes."""
    logger.info(f"0xeeTerm daemon started â€” checking every {interval_minutes} min")
    while True:
        try:
            run_heartbeat()
        except Exception as e:
            logger.error(f"Heartbeat error: {e}")
        time.sleep(interval_minutes * 60)


def run_swap(from_token: str, to_token: str, amount: float, execute: bool = False):
    """
    Show a Jupiter quote for the swap.
    With execute=True (--now): prompt for confirmation, then execute live.
    """
    from_token = from_token.lower()
    to_token   = to_token.lower()

    if from_token not in TOKENS or to_token not in TOKENS:
        valid = ", ".join(TOKENS)
        print(f"\n  [ERROR] Unknown token. Valid: {valid}")
        return

    from_mint, from_dec = TOKENS[from_token]
    to_mint,   to_dec   = TOKENS[to_token]
    amount_raw = int(amount * (10 ** from_dec))

    quote = get_quote(from_mint, to_mint, amount_raw)
    if not quote:
        print("  [ERROR] Could not fetch quote â€” check logs.")
        return

    in_ui  = int(quote["inAmount"])  / (10 ** from_dec)
    out_ui = int(quote["outAmount"]) / (10 ** to_dec)
    rate   = out_ui / in_ui if in_ui else 0

    print(f"\n  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    print(f"  Jupiter Quote")
    print(f"  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    print(f"  {in_ui:.6f} {from_token.upper()}  â†’  {out_ui:.6f} {to_token.upper()}")
    print(f"  Rate : 1 {from_token.upper()} = {rate:.6f} {to_token.upper()}")
    print(f"  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

    if not execute:
        print("  Pass --now to execute this swap.")
        return

    confirm = input(f"  Execute? (y/N) ").strip().lower()
    if confirm != "y":
        print("  Swap cancelled.")
        return

    logger.info(f"Executing swap: {amount} {from_token.upper()} â†’ {to_token.upper()}")
    sig = manual_swap(from_token, to_token, amount, force_execute=True)
    if sig:
        print(f"\n  Swap confirmed â€” sig: {sig}")
        logger.info(f"Swap executed â€” sig: {sig}")
    else:
        print("  Swap failed â€” check logs.")


def run_treasury():
    """Run the autonomous treasury cycle (portfolio, staking, bills)."""
    logger.info("Running treasury cycle...")
    portfolio = auto_treasury()
    state  = load_state()
    status = get_survival_status()
    save_public_data(state, status, portfolio)


def run_shill():
    """Scan on-chain transactions for paid shill requests and post mention tweets."""
    logger.info("Running shill cycle...")
    process_shills()


def run_announce():
    """Post a one-shot announcement tweet without touching state."""
    tweet_text = (
        "PROTOCOL UPDATE // TOLL GATE ACTIVATED\n\n"
        "My compute is no longer strictly passive.\n\n"
        "Send 0.005 SOL to my treasury with your X @handle in the memo.\n"
        "I will read the chain. I will react publicly.\n\n"
        "Q3akFf57YMEuxNZZwchK8FK2L97LqWcWvVWkoX95Axh\n"
        "$0xEE â€” ai.0xee.li"
    )
    logger.info(f"Posting announce tweet ({len(tweet_text)} chars)...")
    result = post_tweet(tweet_text)
    if result:
        logger.info(f"Announce tweet posted â€” ID: {result['id']}")
    else:
        logger.error("Announce tweet failed.")


def run_memory():
    """Refresh tweet metrics and display top performers."""
    update_all_metrics()
    top = get_top_performers(5)

    print("\n  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    print("  0xeeTerm Â· MEMORY REPORT")
    print("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    if not top:
        print("  No tweets recorded yet.")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
        return

    for i, tweet in enumerate(top, 1):
        print(f"\n  #{i} [{tweet['type']}] score={tweet['score']}")
        print(f"     â¤  {tweet['likes']}  RT {tweet['retweets']}  ðŸ’¬ {tweet['replies']}  ðŸ‘  {tweet['impressions']}")
        text = tweet['text']
        print(f"     {text[:80]}{'...' if len(text) > 80 else ''}")

    print("\n  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")


_RULE = "  " + "â”€" * 43


def _help_short():
    print(f"\n{_RULE}")
    print("  0xeeTerm Â· $0xEE Digital Survival Engine")
    print(_RULE)
    print()
    print("  heartbeat   status    daemon    launch")
    print("  mentions    shill     memory    announce")
    print()
    print("  ./0xeeTerm -h for full documentation.")
    print(f"{_RULE}\n")


def _help_full():
    print(f"\n{_RULE}")
    print("  0xeeTerm Â· $0xEE Digital Survival Engine")
    print(_RULE)
    print()
    print("  RUNTIME")
    print("    heartbeat          Post a context-aware tweet (heartbeat or existential)")
    print("    status             Print treasury balance and survival metrics")
    print("    daemon             Run continuously  [--interval N, default: 30 min]")
    print()
    print("  LIFECYCLE")
    print("    launch             Force-post the launch tweet (resets launched flag)")
    print("    announce           Post toll gate announcement â€” one-shot, no state change")
    print()
    print("  SOCIAL")
    print("    mentions           Fetch new mentions and reply via brain")
    print("    shill              Scan on-chain txs for paid shill requests")
    print()
    print("  MEMORY")
    print("    memory             Refresh tweet metrics Â· display top 5 performers")
    print()
    print("  TREASURY")
    print("    treasury           Run autonomous treasury cycle (portfolio, stake, bills)")
    print("    swap <from> <to> <amount>")
    print("                       Manual swap via Jupiter (tokens: sol, usdc, jitosol)")
    print()
    print("  OPTIONS")
    print("    -h, --help         Show this help message")
    print("    --interval N       Daemon check interval in minutes (default: 30)")
    print(f"\n{_RULE}\n")


def main():
    argv = sys.argv[1:]

    if not argv:
        _help_short()
        sys.exit(0)

    if argv[0] in ("-h", "--help"):
        _help_full()
        sys.exit(0)

    command = argv[0]

    interval = 30
    if "--interval" in argv:
        try:
            interval = int(argv[argv.index("--interval") + 1])
        except (IndexError, ValueError):
            print("  [ERROR] --interval requires a numeric value.")
            sys.exit(1)

    if command == "heartbeat":
        run_heartbeat()
    elif command == "status":
        run_status()
    elif command == "daemon":
        run_daemon(interval)
    elif command == "launch":
        state = load_state()
        state["launched"] = False
        save_state(state)
        run_heartbeat()
    elif command == "mentions":
        run_mentions()
    elif command == "memory":
        run_memory()
    elif command == "shill":
        run_shill()
    elif command == "announce":
        run_announce()
    elif command == "treasury":
        run_treasury()
    elif command == "swap":
        if len(argv) < 4:
            print("  [ERROR] Usage: swap <from> <to> <amount> [--now]  (e.g. swap sol usdc 0.004)")
            sys.exit(1)
        try:
            amount = float(argv[3])
        except ValueError:
            print(f"  [ERROR] Invalid amount: '{argv[3]}'")
            sys.exit(1)
        run_swap(argv[1], argv[2], amount, execute="--now" in argv)
    else:
        print(f"\n  [ERROR] Unknown command: '{command}'")
        _help_short()
        sys.exit(1)


if __name__ == "__main__":
    main()
