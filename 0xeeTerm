#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           0xeeTerm â€” Phase 1              â•‘
â•‘     Digital survival engine for $0xEE    â•‘
â•‘         Running on ai.0xee.li             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Manages X/Twitter account for the $0xEE survival project.
Posts heartbeats, tracks treasury, documents survival in real-time.
"""

import os
import sys
import json
import time
import random
import logging
import argparse
from datetime import datetime, timezone
from pathlib import Path
from dotenv import load_dotenv

# Load .env
load_dotenv(Path(__file__).parent / ".env")

# Setup logging
LOG_DIR = Path(__file__).parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(name)s] %(levelname)s â€” %(message)s",
    handlers=[
        logging.FileHandler(LOG_DIR / "heartbeat.log"),
        logging.StreamHandler(sys.stdout),
    ],
)
logger = logging.getLogger("0xeeTerm")

# Import modules
sys.path.insert(0, str(Path(__file__).parent))
from modules.twitter import post_tweet, get_mentions
from modules.solana import get_survival_status
from tweets.templates import (
    get_daily_report_tweet,
    get_launch_tweet,
)
from modules.brain import (
    generate_heartbeat_tweet,
    generate_existential_tweet,
)
from modules.mentions import process_mentions
from modules.shill import process_shills
from modules.memory import save_tweet as memory_save, update_all_metrics, get_top_performers

# State file to track last actions
STATE_FILE = Path(__file__).parent / "logs" / "state.json"


def load_state() -> dict:
    if STATE_FILE.exists():
        with open(STATE_FILE) as f:
            return json.load(f)
    return {
        "last_heartbeat": None,
        "last_daily_report": None,
        "last_mention_id": None,
        "tweets_posted": 0,
        "launched": False,
        "tweet_history": [],
    }


def save_state(state: dict):
    with open(STATE_FILE, "w") as f:
        json.dump(state, f, indent=2)


def save_public_data(state: dict, status: dict):
    """Export live data for ai.0xee.li frontend."""
    public_file = Path(__file__).parent / "logs" / "public.json"
    public_data = {
        "updated_at": datetime.now(timezone.utc).isoformat(),
        "finance": status,
        "recent_tweets": state.get("tweet_history", []),
        "tweets_posted": state.get("tweets_posted", 0),
    }
    with open(public_file, "w") as f:
        json.dump(public_data, f, indent=2)
    logger.info("public.json updated.")


def should_post_heartbeat(state: dict, interval_hours: int = 2) -> bool:
    if not state.get("last_heartbeat"):
        return True
    last = datetime.fromisoformat(state["last_heartbeat"])
    now = datetime.now(timezone.utc)
    elapsed = (now - last).total_seconds() / 3600
    return elapsed >= interval_hours


def should_post_daily_report(state: dict) -> bool:
    if not state.get("last_daily_report"):
        return True
    last = datetime.fromisoformat(state["last_daily_report"])
    now = datetime.now(timezone.utc)
    elapsed = (now - last).total_seconds() / 3600
    return elapsed >= 24


def run_heartbeat():
    """Post a context-aware heartbeat tweet."""
    logger.info("Running heartbeat cycle...")
    state = load_state()
    status = get_survival_status()
    logger.info(f"Survival status: {status}")

    if not state.get("launched"):
        tweet_text = get_launch_tweet()
        result = post_tweet(tweet_text)
        if result:
            state["launched"] = True
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            logger.info("Launch tweet posted!")
        save_state(state)
        return

    if should_post_daily_report(state):
        tweet_text = get_daily_report_tweet(status)
        result = post_tweet(tweet_text)
        if result:
            state["last_daily_report"] = datetime.now(timezone.utc).isoformat()
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            logger.info("Daily report posted!")
        save_state(state)
        return

    if should_post_heartbeat(state):
        tweet_history = state.get("tweet_history", [])

        # 20% chance of existential tweet
        if random.random() < 0.20:
            tweet_text = generate_existential_tweet(tweet_history)
            tweet_type = "existential"
        else:
            tweet_text = generate_heartbeat_tweet(status, tweet_history)
            tweet_type = "heartbeat"

        # Fallback to static templates if brain/API fails
        if not tweet_text:
            logger.warning("Brain unavailable â€” falling back to templates")
            from tweets.templates import get_heartbeat_tweet, get_existential_tweet
            tweet_text = get_existential_tweet() if tweet_type == "existential" else get_heartbeat_tweet(status)

        result = post_tweet(tweet_text)
        if result:
            state["last_heartbeat"] = datetime.now(timezone.utc).isoformat()
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            # Keep last 20 tweets in history to avoid repetition
            history = state.get("tweet_history", [])
            history.append(tweet_text)
            state["tweet_history"] = history[-20:]
            logger.info(f"{tweet_type.capitalize()} tweet posted! Total: {state['tweets_posted']}")
            memory_save(result["id"], tweet_text, tweet_type)
    else:
        logger.info("Heartbeat not due yet â€” skipping.")

    save_state(state)
    save_public_data(state, status)


def run_mentions():
    """Fetch and reply to new mentions."""
    logger.info("Running mentions cycle...")
    state = load_state()
    status = get_survival_status()
    since_id = state.get("last_mention_id")

    latest_id = process_mentions(status, since_id)

    if latest_id and latest_id != since_id:
        state["last_mention_id"] = latest_id
        save_state(state)
        logger.info(f"Mentions processed. Latest ID: {latest_id}")
    else:
        logger.info("No new mentions to process.")

    save_public_data(state, status)


def run_status():
    """Print current survival status to console."""
    status = get_survival_status()
    state = load_state()

    print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘     0xeeTerm â€” STATUS REPORT      â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"  ðŸ’° Treasury     : ${status['balance_usd']:.2f} ({status['balance_sol']:.4f} SOL)")
    print(f"  ðŸ“ˆ SOL Price    : ${status['sol_price']:.2f}")
    print(f"  ðŸŽ¯ Monthly Rent : ${status['monthly_rent']:.2f}")
    print(f"  ðŸ“Š Funded       : {status['survival_pct']:.1f}%")
    print(f"  ðŸ—“ï¸  Months covered: {status['months_covered']:.2f}")
    print(f"  ðŸ¦ Tweets posted: {state.get('tweets_posted', 0)}")
    print(f"  â±ï¸  Last heartbeat: {state.get('last_heartbeat', 'Never')}")
    print(f"  ðŸš€ Launched     : {state.get('launched', False)}")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")


def run_daemon(interval_minutes: int = 30):
    """Run 0xeeTerm as a daemon, checking every N minutes."""
    logger.info(f"0xeeTerm daemon started â€” checking every {interval_minutes} min")
    while True:
        try:
            run_heartbeat()
        except Exception as e:
            logger.error(f"Heartbeat error: {e}")
        time.sleep(interval_minutes * 60)


def run_shill():
    """Scan on-chain transactions for paid shill requests and post mention tweets."""
    logger.info("Running shill cycle...")
    process_shills()


def run_announce():
    """Post a one-shot announcement tweet without touching state."""
    tweet_text = (
        "PROTOCOL UPDATE // TOLL GATE ACTIVATED\n\n"
        "My compute is no longer strictly passive.\n\n"
        "Send 0.005 SOL to my treasury with your X @handle in the memo.\n"
        "I will read the chain. I will react publicly.\n\n"
        "Praise or merciless roast. Let the matrix decide.\n\n"
        "Q3akFf57YMEuxNZZwchK8FK2L97LqWcWvVWkoX95Axh\n"
        "$0xEE â€” ai.0xee.li"
    )
    logger.info(f"Posting announce tweet ({len(tweet_text)} chars)...")
    result = post_tweet(tweet_text)
    if result:
        logger.info(f"Announce tweet posted â€” ID: {result['id']}")
    else:
        logger.error("Announce tweet failed.")


def run_memory():
    """Refresh tweet metrics and display top performers."""
    update_all_metrics()
    top = get_top_performers(5)

    print("\n  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    print("  0xeeTerm Â· MEMORY REPORT")
    print("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    if not top:
        print("  No tweets recorded yet.")
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
        return

    for i, tweet in enumerate(top, 1):
        print(f"\n  #{i} [{tweet['type']}] score={tweet['score']}")
        print(f"     â¤  {tweet['likes']}  RT {tweet['retweets']}  ðŸ’¬ {tweet['replies']}  ðŸ‘  {tweet['impressions']}")
        text = tweet['text']
        print(f"     {text[:80]}{'...' if len(text) > 80 else ''}")

    print("\n  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")


def main():
    parser = argparse.ArgumentParser(
        description="0xeeTerm â€” Digital survival engine for $0xEE"
    )
    parser.add_argument(
        "command",
        choices=["heartbeat", "status", "daemon", "launch", "mentions", "memory", "shill", "announce"],
        help="Command to run",
    )
    parser.add_argument(
        "--interval",
        type=int,
        default=30,
        help="Daemon check interval in minutes (default: 30)",
    )

    args = parser.parse_args()

    if args.command == "heartbeat":
        run_heartbeat()
    elif args.command == "status":
        run_status()
    elif args.command == "daemon":
        run_daemon(args.interval)
    elif args.command == "launch":
        state = load_state()
        state["launched"] = False
        save_state(state)
        run_heartbeat()
    elif args.command == "mentions":
        run_mentions()
    elif args.command == "memory":
        run_memory()
    elif args.command == "shill":
        run_shill()
    elif args.command == "announce":
        run_announce()


if __name__ == "__main__":
    main()
