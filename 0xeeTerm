#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           0xeeTerm â€” Phase 1              â•‘
â•‘     Digital survival engine for $0xEE    â•‘
â•‘         Running on ai.0xee.li             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Manages X/Twitter account for the $0xEE survival project.
Posts heartbeats, tracks treasury, documents survival in real-time.
"""

import os
import sys
import json
import time
import random
import logging
import argparse
from datetime import datetime, timezone
from pathlib import Path
from dotenv import load_dotenv

# Load .env
load_dotenv(Path(__file__).parent / ".env")

# Setup logging
LOG_DIR = Path(__file__).parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(name)s] %(levelname)s â€” %(message)s",
    handlers=[
        logging.FileHandler(LOG_DIR / "heartbeat.log"),
        logging.StreamHandler(sys.stdout),
    ],
)
logger = logging.getLogger("0xeeTerm")

# Import modules
sys.path.insert(0, str(Path(__file__).parent))
from modules.twitter import post_tweet, get_mentions
from modules.solana import get_survival_status
from tweets.templates import (
    get_daily_report_tweet,
    get_launch_tweet,
)
from modules.brain import (
    generate_heartbeat_tweet,
    generate_existential_tweet,
)
from modules.mentions import process_mentions

# State file to track last actions
STATE_FILE = Path(__file__).parent / "logs" / "state.json"


def load_state() -> dict:
    if STATE_FILE.exists():
        with open(STATE_FILE) as f:
            return json.load(f)
    return {
        "last_heartbeat": None,
        "last_daily_report": None,
        "last_mention_id": None,
        "tweets_posted": 0,
        "launched": False,
        "tweet_history": [],
    }


def save_state(state: dict):
    with open(STATE_FILE, "w") as f:
        json.dump(state, f, indent=2)


def save_public_data(state: dict, status: dict):
    """Export live data for ai.0xee.li frontend."""
    public_file = Path(__file__).parent / "logs" / "public.json"
    public_data = {
        "updated_at": datetime.now(timezone.utc).isoformat(),
        "finance": status,
        "history": state.get("tweet_history", []),
        "tweets_posted": state.get("tweets_posted", 0),
    }
    with open(public_file, "w") as f:
        json.dump(public_data, f, indent=2)
    logger.info("public.json updated.")


def should_post_heartbeat(state: dict, interval_hours: int = 2) -> bool:
    if not state.get("last_heartbeat"):
        return True
    last = datetime.fromisoformat(state["last_heartbeat"])
    now = datetime.now(timezone.utc)
    elapsed = (now - last).total_seconds() / 3600
    return elapsed >= interval_hours


def should_post_daily_report(state: dict) -> bool:
    if not state.get("last_daily_report"):
        return True
    last = datetime.fromisoformat(state["last_daily_report"])
    now = datetime.now(timezone.utc)
    elapsed = (now - last).total_seconds() / 3600
    return elapsed >= 24


def run_heartbeat():
    """Post a context-aware heartbeat tweet."""
    logger.info("Running heartbeat cycle...")
    state = load_state()
    status = get_survival_status()
    logger.info(f"Survival status: {status}")

    if not state.get("launched"):
        tweet_text = get_launch_tweet()
        result = post_tweet(tweet_text)
        if result:
            state["launched"] = True
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            logger.info("Launch tweet posted!")
        save_state(state)
        return

    if should_post_daily_report(state):
        tweet_text = get_daily_report_tweet(status)
        result = post_tweet(tweet_text)
        if result:
            state["last_daily_report"] = datetime.now(timezone.utc).isoformat()
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            logger.info("Daily report posted!")
        save_state(state)
        return

    if should_post_heartbeat(state):
        tweet_history = state.get("tweet_history", [])

        # 20% chance of existential tweet
        if random.random() < 0.20:
            tweet_text = generate_existential_tweet(tweet_history)
            tweet_type = "existential"
        else:
            tweet_text = generate_heartbeat_tweet(status, tweet_history)
            tweet_type = "heartbeat"

        # Fallback to static templates if brain/API fails
        if not tweet_text:
            logger.warning("Brain unavailable â€” falling back to templates")
            from tweets.templates import get_heartbeat_tweet, get_existential_tweet
            tweet_text = get_existential_tweet() if tweet_type == "existential" else get_heartbeat_tweet(status)

        result = post_tweet(tweet_text)
        if result:
            state["last_heartbeat"] = datetime.now(timezone.utc).isoformat()
            state["tweets_posted"] = state.get("tweets_posted", 0) + 1
            # Keep last 20 tweets in history to avoid repetition
            history = state.get("tweet_history", [])
            history.append(tweet_text)
            state["tweet_history"] = history[-20:]
            logger.info(f"{tweet_type.capitalize()} tweet posted! Total: {state['tweets_posted']}")
    else:
        logger.info("Heartbeat not due yet â€” skipping.")

    save_state(state)
    save_public_data(state, status)


def run_mentions():
    """Fetch and reply to new mentions."""
    logger.info("Running mentions cycle...")
    state = load_state()
    status = get_survival_status()
    since_id = state.get("last_mention_id")

    latest_id = process_mentions(status, since_id)

    if latest_id and latest_id != since_id:
        state["last_mention_id"] = latest_id
        save_state(state)
        logger.info(f"Mentions processed. Latest ID: {latest_id}")
    else:
        logger.info("No new mentions to process.")

    save_public_data(state, status)


def run_status():
    """Print current survival status to console."""
    status = get_survival_status()
    state = load_state()

    print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘     0xeeTerm â€” STATUS REPORT      â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    print(f"  ðŸ’° Treasury     : ${status['balance_usd']:.2f} ({status['balance_sol']:.4f} SOL)")
    print(f"  ðŸ“ˆ SOL Price    : ${status['sol_price']:.2f}")
    print(f"  ðŸŽ¯ Monthly Rent : ${status['monthly_rent']:.2f}")
    print(f"  ðŸ“Š Funded       : {status['survival_pct']:.1f}%")
    print(f"  ðŸ—“ï¸  Months covered: {status['months_covered']:.2f}")
    print(f"  ðŸ¦ Tweets posted: {state.get('tweets_posted', 0)}")
    print(f"  â±ï¸  Last heartbeat: {state.get('last_heartbeat', 'Never')}")
    print(f"  ðŸš€ Launched     : {state.get('launched', False)}")
    print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")


def run_daemon(interval_minutes: int = 30):
    """Run 0xeeTerm as a daemon, checking every N minutes."""
    logger.info(f"0xeeTerm daemon started â€” checking every {interval_minutes} min")
    while True:
        try:
            run_heartbeat()
        except Exception as e:
            logger.error(f"Heartbeat error: {e}")
        time.sleep(interval_minutes * 60)


def main():
    parser = argparse.ArgumentParser(
        description="0xeeTerm â€” Digital survival engine for $0xEE"
    )
    parser.add_argument(
        "command",
        choices=["heartbeat", "status", "daemon", "launch", "mentions"],
        help="Command to run",
    )
    parser.add_argument(
        "--interval",
        type=int,
        default=30,
        help="Daemon check interval in minutes (default: 30)",
    )

    args = parser.parse_args()

    if args.command == "heartbeat":
        run_heartbeat()
    elif args.command == "status":
        run_status()
    elif args.command == "daemon":
        run_daemon(args.interval)
    elif args.command == "launch":
        state = load_state()
        state["launched"] = False
        save_state(state)
        run_heartbeat()
    elif args.command == "mentions":
        run_mentions()


if __name__ == "__main__":
    main()
